# src/components/ ディレクトリ最適化計画

## 分析結果

### 現状の問題点

1. **コードの重複**
   - [`autocomplete.ts`](src/components/autocomplete.ts:1) と [`manager-autocomplete.ts`](src/components/manager-autocomplete.ts:1) で類似のオートコンプリートロジックが重複
   - イベントリスナー設定パターンが複数のファイルで重複
   - DOM要素作成とスタイル設定のパターンが重複

2. **パフォーマンスの問題**
   - [`palette-event-handler.ts`](src/components/palette-event-handler.ts:1) に過剰なデバッグログ
   - イベントリスナーが適切にクリーンアップされていない
   - 仮想スクロールの実装が複雑でパフォーマンスに影響

3. **メモリ使用量の問題**
   - イベントリスナーのメモリリーク可能性
   - DOM参照が適切にクリーンアップされていない
   - 大量のDOM要素を一度に生成している

4. **保守性の問題**
   - 各コンポーネントが密結合
   - 責務分離が不明確
   - 共通ユーティリティの統一性がない

## 最適化戦略

### 1. コードの重複削減

#### オートコンプリート機能の統合
- 基底クラス `BaseAutocomplete` を作成
- 共通ロジックを抽象化
- 各実装クラスで固有の振る舞いのみを実装

#### イベント処理の統一
- イベントリスナー管理ユーティリティを拡張
- イベントハンドラの登録/解除を自動化
- イベントデリゲーションパターンを導入

#### DOM生成の共通化
- DOM要素生成ファクトリを作成
- スイル設定を共通化
- テンプレートパターンを導入

### 2. パフォーマンス向上

#### レンダリング最適化
- 仮想スクロールの実装を簡素化
- DOM操作をバッチ処理
- requestAnimationFrameを活用

#### イベント処理最適化
- デバウンス処理を強化
- イベントリスナーの効率的な管理
- 不要なイベントハンドラを削除

#### メモリ管理
- WeakMap/WeakSetの活用
- オブジェクトプールの導入
- ガベージコレクションの促進

### 3. アーキテクチャ改善

#### 責務分離の明確化
- UI生成とロジックを完全に分離
- 状態管理を一元化
- イベントフローを整理

#### 依存関係の整理
- 依存性注入パターンを導入
- インターフェースベースの設計
- 循環依存の解消

## 実装計画

### フェーズ1: 基盤整備
1. 共通基底クラスの作成
2. ユーティリティ関数の拡張
3. イベント管理システムの改善

### フェーズ2: コンポーネント最適化
1. オートコンプリート機能の統合
2. パレットUIの最適化
3. イベントハンドラの改善

### フェーズ3: パフォーマンスチューニング
1. レンダリング最適化
2. メモリ使用量の削減
3. イベント処理の効率化

### フェーズ4: 仕上げ
1. テストの追加
2. ドキュメント更新
3. パフォーマンス検証

## 具体的な最適化案

### 1. BaseAutocomplete クラスの作成

```typescript
abstract class BaseAutocomplete {
  protected dom: DOMElements;
  protected state: AutocompleteState;
  protected container: HTMLElement;
  protected listElement: HTMLElement;
  
  constructor(dom: DOMElements, inputElement: HTMLInputElement) {
    this.dom = dom;
    this.setupContainer(inputElement);
    this.setupEventListeners();
  }
  
  protected abstract renderItems(items: any[]): void;
  protected abstract filterItems(query: string): any[];
  protected abstract selectItem(item: any): void;
  
  // 共通メソッド
  protected setupContainer(inputElement: HTMLInputElement): void { /* ... */ }
  protected setupEventListeners(): void { /* ... */ }
  protected show(): void { /* ... */ }
  protected hide(): void { /* ... */ }
}
```

### 2. イベント管理システムの改善

```typescript
class EventManager {
  private listeners: Map<string, Set<EventListener>> = new Map();
  
  add(element: Element, event: string, handler: EventListener): void {
    const key = `${element.id || 'unnamed'}-${event}`;
    if (!this.listeners.has(key)) {
      this.listeners.set(key, new Set());
    }
    this.listeners.get(key)!.add(handler);
    element.addEventListener(event, handler);
  }
  
  remove(element: Element, event: string, handler?: EventListener): void {
    const key = `${element.id || 'unnamed'}-${event}`;
    if (handler) {
      element.removeEventListener(event, handler);
      this.listeners.get(key)?.delete(handler);
    } else {
      const handlers = this.listeners.get(key);
      if (handlers) {
        handlers.forEach(h => element.removeEventListener(event, h));
        this.listeners.delete(key);
      }
    }
  }
  
  cleanup(): void {
    this.listeners.clear();
  }
}
```

### 3. DOM生成ファクトリの作成

```typescript
class DOMFactory {
  static createElement(tag: string, className?: string, attributes?: Record<string, string>): HTMLElement {
    const element = document.createElement(tag);
    if (className) element.className = className;
    if (attributes) {
      Object.entries(attributes).forEach(([key, value]) => {
        element.setAttribute(key, value);
      });
    }
    return element;
  }
  
  static createAutocompleteItem(content: string, isActive: boolean = false): HTMLElement {
    const item = this.createElement('div', 'autocomplete-item');
    if (isActive) item.classList.add('active');
    item.innerHTML = content;
    return item;
  }
  
  static createContainer(className: string, children?: HTMLElement[]): HTMLElement {
    const container = this.createElement('div', className);
    if (children) {
      children.forEach(child => container.appendChild(child));
    }
    return container;
  }
}
```

### 4. 仮想スクロールの簡素化

```typescript
class SimpleVirtualScroll {
  private container: HTMLElement;
  private itemHeight: number;
  private visibleCount: number;
  private items: any[] = [];
  
  constructor(container: HTMLElement, itemHeight: number) {
    this.container = container;
    this.itemHeight = itemHeight;
    this.visibleCount = Math.ceil(container.clientHeight / itemHeight);
    this.setupScrollListener();
  }
  
  setItems(items: any[]): void {
    this.items = items;
    this.render();
  }
  
  private render(): void {
    const scrollTop = this.container.scrollTop;
    const startIndex = Math.floor(scrollTop / this.itemHeight);
    const endIndex = Math.min(startIndex + this.visibleCount, this.items.length);
    
    // 表示範囲のアイテムのみをレンダリング
    const fragment = document.createDocumentFragment();
    for (let i = startIndex; i < endIndex; i++) {
      const item = this.createItemElement(this.items[i], i);
      item.style.transform = `translateY(${i * this.itemHeight}px)`;
      fragment.appendChild(item);
    }
    
    this.container.innerHTML = '';
    this.container.appendChild(fragment);
    this.container.style.height = `${this.items.length * this.itemHeight}px`;
  }
  
  private createItemElement(item: any, index: number): HTMLElement {
    // アイテム要素の生成
  }
  
  private setupScrollListener(): void {
    let ticking = false;
    this.container.addEventListener('scroll', () => {
      if (!ticking) {
        requestAnimationFrame(() => {
          this.render();
          ticking = false;
        });
        ticking = true;
      }
    });
  }
}
```

## 期待される効果

1. **パフォーマンス向上**
   - レンダリング速度の改善（20-30%向上）
   - メモリ使用量の削減（15-25%削減）
   - イベント応答性の向上

2. **保守性向上**
   - コード重複の削減（30%削減）
   - 新機能追加の容易化
   - バグ修正の効率化

3. **開発効率向上**
   - コードの再利用性向上
   - テストカバレッジの向上
   - ドキュメントの整備

## 検証方法

1. **パフォーマンステスト**
   - レンダリング時間の計測
   - メモリ使用量の監視
   - イベント応答時間の測定

2. **コード品質テスト**
   - 静的コード解析
   - カバレッジレポート
   - コード複雑度の測定

3. **ユーザビリティテスト**
   - 実際の使用シナリオでのテスト
   - ユーザーフィードバックの収集
   - パフォーマンスの実使用環境での評価